name: build-images

on:
  workflow_call:
    inputs:
      # 'skip' is kind of silly. it exists because we can't actually *skip* this job from e2e-test,
      # otherwise the follow-up job that needs it wouldn't be able to run. So instead we pretend the
      # job completed successfully, but actually do nothing...
      skip:
        description: 'Changes this action to perform a no-op'
        type: boolean
        required: false
      tag:
        description: 'Tag to use for the Docker images'
        type: string
        required: true
      kernel-image:
        description: 'Kernel image for the VMs embedded in neonvm-runner. If not specified, a kernel will be built from source'
        type: string
        required: false
      build-cluster-autoscaler:
        description: 'Build the custom cluster-autoscaler image'
        type: boolean
        required: false
      controller-preserve-runner-pods:
        description: 'ONLY USE FOR E2E TESTS: Set neonvm-controller to never delete VM runner pods'
        type: boolean
        required: false
      upload-to-ecr:
        description: 'Should images be uploaded to neon ECR'
        type: boolean
        required: false
      arch:
        description: 'Architecture to build for'
        type: string
        required: false
        default: 'amd64'
      matrix-step-name:
        required: false
        type: string
      matrix-key:
        required: false
        type: string

    outputs:

      controller:
        description: 'neonvm-controller image'
        value: ${{ jobs.save-matrix-results.outputs.controller }}
      vxlan-controller:
        description: 'neonvm-vxlan-controller image'
        value: ${{ jobs.save-matrix-results.outputs.vxlan-controller}}
      runner:
        description: 'neonvm-runner image'
        value: ${{ jobs.save-matrix-results.outputs.runner}}
      scheduler:
        description: 'autoscale-scheduler image'
        value: ${{ jobs.save-matrix-results.outputs.scheduler}}
      autoscaler-agent:
        description: 'autoscaler-agent image'
        value: ${{ jobs.tags.outputs.autoscaler-agent }}
      daemon:
        description: 'neonvm-daemon image'
        value: ${{ jobs.tags.outputs.daemon }}

env:
  IMG_CONTROLLER:         "neondatabase/neonvm-controller"
  IMG_VXLAN_CONTROLLER:   "neondatabase/neonvm-vxlan-controller"
  IMG_RUNNER:             "neondatabase/neonvm-runner"
  IMG_KERNEL:             "neondatabase/vm-kernel"
  IMG_SCHEDULER:          "neondatabase/autoscale-scheduler"
  IMG_AUTOSCALER_AGENT:   "neondatabase/autoscaler-agent"
  IMG_DAEMON:             "neondatabase/neonvm-daemon"
  IMG_CLUSTER_AUTOSCALER: "neondatabase/cluster-autoscaler-neonvm"
  ECR_DEV:                "369495373322.dkr.ecr.eu-central-1.amazonaws.com"
  ECR_PROD:               "093970136003.dkr.ecr.eu-central-1.amazonaws.com"

defaults:
  run:
    shell: bash -euo pipefail {0}

jobs:
  tags:
    outputs:
      controller:         ${{ steps.show-tags.outputs.controller }}
      vxlan-controller:   ${{ steps.show-tags.outputs.vxlan-controller }}
      runner:             ${{ steps.show-tags.outputs.runner }}
      scheduler:          ${{ steps.show-tags.outputs.scheduler }}
      autoscaler-agent:   ${{ steps.show-tags.outputs.autoscaler-agent }}
      cluster-autoscaler: ${{ steps.show-tags.outputs.cluster-autoscaler }}
      daemon:             ${{ steps.show-tags.outputs.daemon }}
    runs-on: ubuntu-latest
    steps:
      - id: show-tags
        run: |
          echo "controller=${{ env.IMG_CONTROLLER }}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "vxlan-controller=${{ env.IMG_VXLAN_CONTROLLER }}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "runner=${{ env.IMG_RUNNER }}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "scheduler=${{ env.IMG_SCHEDULER }}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "autoscaler-agent=${{ env.IMG_AUTOSCALER_AGENT }}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "cluster-autoscaler=${{ env.IMG_CLUSTER_AUTOSCALER }}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "daemon=${{ env.IMG_DAEMON }}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT

  vm-kernel:
    # nb: use format(..) to catch both inputs.skip = true AND inputs.skip = 'true'.
    if: ${{ format('{0}', inputs.skip) != 'true' }}
    uses: ./.github/workflows/vm-kernel.yaml
    with:
      tag: ${{ inputs.kernel-image || inputs.tag }}
      return-image-for-tag: ${{ inputs.kernel-image }}
      arch: ${{ inputs.arch }}
    secrets: inherit

  build:
    # nb: use format(..) to catch both inputs.skip = true AND inputs.skip = 'true'.
    if: ${{ format('{0}', inputs.skip) != 'true' }}
    needs: [ vm-kernel ]
    outputs:
      controller:         ${{ steps.tags.outputs.controller }}
      vxlan-controller:   ${{ steps.tags.outputs.vxlan-controller }}
      runner:             ${{ steps.tags.outputs.runner }}
      scheduler:          ${{ steps.tags.outputs.scheduler }}
      autoscaler-agent:   ${{ steps.tags.outputs.autoscaler-agent }}
      cluster-autoscaler: ${{ steps.tags.outputs.cluster-autoscaler }}
    env:
      # Why localhost? We use a local registry so that when docker/build-push-action tries to pull the
      # image we built locally, it'll actually have a place to pull from.
      #
      # Otherwise, if we just try to use a local image, it fails trying to pull it from dockerhub.
      # See https://github.com/moby/buildkit/issues/2343 for more information.
      GO_BASE_IMG: ${{ format('localhost:5000/neondatabase/autoscaling-go-base-{0}:dev', inputs.arch) }}
    permissions:
      contents: read  # This is required for actions/checkout
      id-token: write # This is required for aws-actions/configure-aws-credentials

    runs-on: ${{ fromJson(format('["self-hosted", "{0}"]', inputs.arch == 'arm64' && 'large-arm64' || 'large')) }}

    services:
      registry:
        image: registry:2
        ports:
          - 5000:5000

    steps:
      # tags converted to be a step and moved here to be in the same strategy context

      - id: tags
        run: |
          echo "controller=${{ env.IMG_CONTROLLER }}-${{inputs.arch}}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "vxlan-controller=${{ env.IMG_VXLAN_CONTROLLER }}-${{inputs.arch}}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "runner=${{ env.IMG_RUNNER }}-${{inputs.arch}}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "scheduler=${{ env.IMG_SCHEDULER }}-${{inputs.arch}}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "autoscaler-agent=${{ env.IMG_AUTOSCALER_AGENT }}-${{inputs.arch}}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "cluster-autoscaler=${{ env.IMG_CLUSTER_AUTOSCALER }}-${{inputs.arch}}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT
          echo "daemon=${{ env.IMG_DAEMON }}-${{inputs.arch}}:${{ inputs.tag }}" | tee -a $GITHUB_OUTPUT

      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          # Disable cache on self-hosted runners to avoid /usr/bin/tar errors, see https://github.com/actions/setup-go/issues/403
          cache: false
        # Sometimes setup-go gets stuck. Without this, it'll keep going until the job gets killed
        timeout-minutes: 10

      # Use 'git describe' for embedding git information (duplicated from the Makefile)
      - name: get git info
        id: get-git-info
        run: |
          # note: --tags enables matching on lightweight (i.e. not annotated) tags, which normally
          # wouldn't be necessary, except that actions/checkout@v4 does weird things to setup the
          # repository that means that we actually end up checked out with *just* a lightweight tag
          # to the tagged commit.
          echo "info=$(git describe --tags --long --dirty)" >> $GITHUB_OUTPUT

      - name: set custom docker config directory
        uses: neondatabase/dev-actions/set-docker-config-dir@6094485bf440001c94a94a3f9e221e81ff6b6193

      - uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host


      - name: Login to Dockerhub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.NEON_DOCKERHUB_USERNAME }}
          password: ${{ secrets.NEON_DOCKERHUB_PASSWORD }}

      - name: Login to Docker cache registry
        uses: docker/login-action@v3
        with:
          registry: cache.neon.build
          username: ${{ secrets.NEON_CI_DOCKERCACHE_USERNAME }}
          password: ${{ secrets.NEON_CI_DOCKERCACHE_PASSWORD }}
      - name: Configure dev AWS credentials
        if: ${{ format('{0}', inputs.upload-to-ecr) == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: eu-central-1
          mask-aws-account-id: true
          role-to-assume: ${{ secrets.DEV_GHA_OIDC_ECR_ROLE }}

      - name: Login to dev ECR
        if: ${{ format('{0}', inputs.upload-to-ecr) == 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ECR_DEV }}

      - name: Configure prod AWS credentials
        if: ${{ format('{0}', inputs.upload-to-ecr) == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: eu-central-1
          mask-aws-account-id: true
          role-to-assume: ${{ secrets.PROD_GHA_OIDC_ECR_ROLE }}

      - name: Login to prod ECR
        if: ${{ format('{0}', inputs.upload-to-ecr) == 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ECR_PROD }}

      - name: Check dependencies
        run: |
          docker version
          docker buildx version

      - name: Load VM kernel
        env:
          IMAGE: ${{ needs.vm-kernel.outputs.image }}
        run: |
          docker pull --quiet $IMAGE
          ID=$(docker create $IMAGE true)
          docker cp ${ID}:/vmlinuz neonvm-kernel/vmlinuz
          docker rm -f ${ID}

      - name: Build go dependencies image
        uses: docker/build-push-action@v6
        id: build-go-dependencies-image
        with:
          context: .

          push: true
          file: Dockerfile.go-base
          cache-from: type=registry,ref=cache.neon.build/autoscaling-go-base:cache
          cache-to: ${{ github.ref_name == 'main' && 'type=registry,ref=cache.neon.build/autoscaling-go-base:cache,mode=max' || '' }}
          tags: ${{ env.GO_BASE_IMG }}

      - name: Build and push neonvm-runner image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/${{ inputs.arch }}
          file: neonvm-runner/Dockerfile
          cache-from: type=registry,ref=cache.neon.build/neonvm-runner:cache
          cache-to: ${{ github.ref_name == 'main' && 'type=registry,ref=cache.neon.build/neonvm-runner:cache,mode=max' || '' }}
          tags: ${{ steps.tags.outputs.runner }}
          build-args: |
            GO_BASE_IMG=${{ env.GO_BASE_IMG }}

      - name: Generate neonvm-controller build tags
        id: controller-build-tags
        env:
          PRESERVE_RUNNER_PODS: ${{ inputs.controller-preserve-runner-pods }}
        run: |
          if [ "$PRESERVE_RUNNER_PODS" = 'true' ]; then
            echo "buildtags=nodelete" | tee -a $GITHUB_OUTPUT
          else
            echo "buildtags=" | tee -a $GITHUB_OUTPUT
          fi

      - name: Build and push neonvm-controller image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/${{ inputs.arch }}
          push: true
          file: neonvm-controller/Dockerfile
          cache-from: type=registry,ref=cache.neon.build/neonvm-controller:cache
          cache-to: ${{ github.ref_name == 'main' && 'type=registry,ref=cache.neon.build/neonvm-controller:cache,mode=max' || '' }}
          tags: ${{ steps.tags.outputs.controller }}
          build-args: |
            GO_BASE_IMG=${{ env.GO_BASE_IMG }}
            VM_RUNNER_IMAGE=${{ steps.tags.outputs.runner }}
            BUILDTAGS=${{ steps.controller-build-tags.outputs.buildtags }}

      - name: Build and push neonvm-vxlan-controller image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/${{ inputs.arch }}
          push: true
          file: neonvm-vxlan-controller/Dockerfile
          cache-from: type=registry,ref=cache.neon.build/neonvm-vxlan-controller:cache
          cache-to: ${{ github.ref_name == 'main' && 'type=registry,ref=cache.neon.build/neonvm-vxlan-controller:cache,mode=max' || '' }}
          tags: ${{ steps.tags.outputs.vxlan-controller }}
          build-args: |
            GO_BASE_IMG=${{ env.GO_BASE_IMG }}
            TARGET_ARCH=${{ inputs.arch }}

      - name: Build and push autoscale-scheduler image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/${{ inputs.arch }}
          push: true
          file: autoscale-scheduler/Dockerfile
          cache-from: type=registry,ref=cache.neon.build/autoscale-scheduler:cache
          cache-to: ${{ github.ref_name == 'main' && 'type=registry,ref=cache.neon.build/autoscale-scheduler:cache,mode=max' || '' }}
          tags: ${{ steps.tags.outputs.scheduler}}
          build-args: |
            GO_BASE_IMG=${{ env.GO_BASE_IMG }}
            GIT_INFO=${{ steps.get-git-info.outputs.info }}:${{ inputs.tag }}

      - name: Build and push autoscaler-agent image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/${{ inputs.arch }}
          push: true
          file: autoscaler-agent/Dockerfile
          cache-from: type=registry,ref=cache.neon.build/autoscaler-agent:cache
          cache-to: ${{ github.ref_name == 'main' && 'type=registry,ref=cache.neon.build/autoscaler-agent:cache,mode=max' || '' }}
          tags: ${{ steps.tags.outputs.autoscaler-agent}}
          build-args: |
            GO_BASE_IMG=${{ env.GO_BASE_IMG }}
            GIT_INFO=${{ steps.get-git-info.outputs.info }}

      - name: Build and push neonvm-daemon image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/${{ inputs.arch }}
          push: true
          file: neonvm-daemon/Dockerfile
          cache-from: type=registry,ref=cache.neon.build/neonvm-daemon:cache
          cache-to: ${{ github.ref_name == 'main' && 'type=registry,ref=cache.neon.build/neonvm-daemon:cache,mode=max' || '' }}
          tags: ${{ steps.tags.outputs.daemon }}
          build-args: |
            GO_BASE_IMG=${{ env.GO_BASE_IMG }}

      - name: Build and push cluster-autoscaler image
        uses: docker/build-push-action@v6
        if: ${{ format('{0}', inputs.build-cluster-autoscaler) == 'true' }}
        with:
          context: cluster-autoscaler
          platforms: linux/${{ inputs.arch }}
          push: true
          target: ${{format('cluster_autoscaler_{0}', inputs.arch)}}
          tags: ${{ steps.tags.outputs.cluster-autoscaler}}
          cache-from: type=registry,ref=cache.neon.build/cluster-autoscaler-neonvm:cache
          cache-to: ${{ github.ref_name == 'main' && 'type=registry,ref=cache.neon.build/cluster-autoscaler-neonvm:cache,mode=max' || '' }}

      - name: Copy all images to ECR
        if: ${{ format('{0}', inputs.upload-to-ecr) == 'true' }}
        run: |
          for image in \
            neonvm-controller \
            neonvm-vxlan-controller \
            neonvm-runner \
            vm-kernel \
            autoscale-scheduler \
            autoscaler-agent \
            cluster-autoscaler-neonvm \
            ; do
            echo Copy ${image}:${{ inputs.tag }} to dev ECR
            docker buildx imagetools create -t ${{ env.ECR_DEV }}/${image}:${{ inputs.tag }} \
                                               neondatabase/${image}:${{ inputs.tag }}
            echo Copy ${image}:${{ inputs.tag }} to prod ECR
            docker buildx imagetools create -t ${{ env.ECR_PROD }}/${image}:${{ inputs.tag }} \
                                               neondatabase/${image}:${{ inputs.tag }}
          done

  save-matrix-results:
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      ## Write for matrix outputs workaround
      - uses: cloudposse/github-action-matrix-outputs-write@v1
        id: out
        with:
          matrix-step-name: ${{ inputs.matrix-step-name }}
          matrix-key: ${{ inputs.matrix-key }}
          outputs: |-
              controller:         ${{ needs.build.outputs.controller }}
              vxlan-controller:   ${{ needs.build.outputs.vxlan-controller }}
              runner:             ${{ needs.build.outputs.runner }}
              scheduler:          ${{ needs.build.outputs.scheduler }}
              autoscaler-agent:   ${{ needs.build.outputs.autoscaler-agent }}
              cluster-autoscaler: ${{ needs.build.outputs.cluster-autoscaler }}

    outputs:
      controller: ${{ steps.out.outputs.controller }}
      vxlan-controller: ${{ steps.out.outputs.vxlan-controller }}
      runner: ${{ steps.out.outputs.runner }}
      scheduler: ${{ steps.out.outputs.scheduler }}
      autoscaler-agent: ${{ steps.out.outputs.autoscaler-agent }}
      cluster-autoscaler: ${{ steps.out.outputs.cluster-autoscaler }}
